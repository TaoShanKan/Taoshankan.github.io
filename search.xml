<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从编码到黑客：使用(外部)游戏黑客入门指南</title>
      <link href="/2018/04/15/%E4%BB%8E%E7%BC%96%E7%A0%81%E5%88%B0%E9%BB%91%E5%AE%A2%EF%BC%9A%E4%BD%BF%E7%94%A8%EF%BC%88%E5%A4%96%E9%83%A8%EF%BC%89%E6%B8%B8%E6%88%8F%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/04/15/%E4%BB%8E%E7%BC%96%E7%A0%81%E5%88%B0%E9%BB%91%E5%AE%A2%EF%BC%9A%E4%BD%BF%E7%94%A8%EF%BC%88%E5%A4%96%E9%83%A8%EF%BC%89%E6%B8%B8%E6%88%8F%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>在国外UC论坛看到一篇入门教学指南，故在此总结，一边学习一边写.<strong>我只是业余学习,这相当于是一个私人笔记</strong>。</p><a id="more"></a><p>对于黑客,有很多可用的学习资料,但是缺乏明确的路径,让人感觉有一道无法逾越的鸿沟.我们需要填补这一空白,并为任何学习编码入门(外部)游戏黑客的人提供一条清晰的路径.<strong>本教程需要使用C++语言</strong>.</p><h2 id="为了实现这一目标-我们将要"><a href="#为了实现这一目标-我们将要" class="headerlink" title="为了实现这一目标,我们将要:"></a>为了实现这一目标,我们将要:</h2><ol><li>编写一个<strong>小型目标程序</strong>,我们将其用于实验.(他将模拟我们试图攻破的游戏或者程序,同时保持简洁和清晰透明)</li><li>获得<strong>Windows API</strong>的第一次体验.</li><li>读取和编写另一个程序的<strong>内存</strong>.(这是外部作弊的本质,这是使其他很多事情变得可能的核心)</li><li>逆向设计一款真正的游戏:Assault Cube(免费,开源代码,非常轻便且配置要求极低),这将为你带来逆向工程初次体验的基本技能,包括2个非常重要的工具:<strong>Cheat Engine</strong>和<strong>ReClass</strong>.</li><li><strong>编码破解</strong>,将修改游戏内存以获取作弊的功能,如无敌,无限弹药,瞬移等等.</li><li><strong>编码雷达和GPS</strong>,这将教会你如何处理收集到的游戏内存数据,通过编码获取实际功能.你也会制作你的第一个窗口,并在上面画上你的雷达.</li><li><strong>编码一个完整的ESP</strong>,检测敌人的位置并精确的显示他们在屏幕上的位置.</li><li>我们将分析反作弊操作的基本原理和一些基本的规避方法(这些方法可能被目前主流的反作弊发现)</li></ol><h2 id="要求-目标受众"><a href="#要求-目标受众" class="headerlink" title="要求/目标受众"></a>要求/目标受众</h2><blockquote><p><strong><em>教程针对所有学习过适合游戏黑客的编程语言(C/C++,C#等)的人,你不一定要成为这门语言的大师,但你不应该为了基本的东西挣扎</em></strong>.</p></blockquote><h2 id="外部作弊-原理与概念"><a href="#外部作弊-原理与概念" class="headerlink" title="外部作弊:原理与概念"></a>外部作弊:原理与概念</h2><p><strong>外部作弊通常会读取目标游戏/进程的内存以提取有价值的信息以获取优势.</strong></p><p>例如,检索角色的3D位置和其他玩家的位置,以便将其显示在雷达上,或者直接显示在屏幕上,就像ESP作弊(透视).</p><p>这种类型的作弊行为还可以覆盖目标内存来改变数值,例如将玩家的生命值维持在最大值,给与无限的弹药等等…</p><p><strong>我们称之为”外部作弊”,它在一个单独的进程中运行,而不是它所入侵的游戏/程序.</strong></p><p>相反,”内部作弊”是从被黑客入侵的游戏/程序中运行,因此,这两种方式的读取和写入目标数据的方法不同.</p><p><strong>Microsft Windows操作系统提供了一组函数,它们允许我们读取和写入另一个程序的内存,名为<a href="https://msdn.microsoft.com/en-us/library/ms680553(VS.85" target="_blank" rel="noopener">ReadProcessMemory</a>.aspx)和<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85" target="_blank" rel="noopener">WriteProcessMemory</a>.aspx)(缩写为RPM和WPM).</strong></p><p>注意:这不是外部作弊读取和写入另一进程内存的唯一方式.</p><p>还可以使用驱动程序来读取和写入另一进程内存.</p><h2 id="“虚拟程序”-编写我们的虚拟目标程序"><a href="#“虚拟程序”-编写我们的虚拟目标程序" class="headerlink" title="“虚拟程序”:编写我们的虚拟目标程序"></a>“虚拟程序”:编写我们的虚拟目标程序</h2><p>这部分练习有2个目的:</p><ol><li>为了给我们提供一个试图破解的虚拟程序,它将模拟我们的目标程序.</li><li>过滤学习者:<u>如果你不能完成第一次练习,你应该考虑你的编码没有达到这个教程的水平,你应当阅读学习你的编程语言的更多教程,学会更多之后再来</u>.不要坚持强迫自己,这回让你因为缺乏经验而感到沮丧并早早放弃.</li></ol><h4 id="方向"><a href="#方向" class="headerlink" title="方向:"></a>方向:</h4><p>你将编写一个简单的控制台程序,在main()的代码中实现下面所有东西:</p><ul><li>声明一个名为varInt的类型为integer的变量等于123456.</li><li>用文本”DefaultString”声明一个名为VarSting的string类型变量.</li><li>声明一个名为arrChar的字符数组，其大小为128，文本为“Long char array right there - &gt;”,可以将它的大小放在一个声明的常量中.</li><li>声明一个名为ptr2int的int指针指向varInt .</li><li>声明一个名为ptr2ptr的int指针指向指针ptr2int.</li><li>声明一个名为ptr2ptr2的int指针指向指针ptr2prt.</li></ul><p>一旦这个完成后,创建一个无限循环,并在其中:</p><ul><li>打印到控制台”Process ID:”,后面跟着使用Windows API函数[GetCurrentProcessId()获取程序的进程ID (因此，请不要忘记#include &lt;Windows.h&gt; !!)</li><li>打印到控制台”varInt (0x[地址或者变量]) = [变量的值]”(通过”&amp;”获取变量的地址)</li><li>对VarSting和arrChar做同样的打印</li><li>打印我们的三个指针,例如”ptr2int (0x[地址或者指针]) = 0x[地址]”</li><li>打印”按下回车再次打印”</li><li>放置暂停,你可以使用getchar()或者system(“pause&gt;nul”)</li><li>打印一行破折号(“-“),然后回到循环的开始</li></ul><p>这是预期的输出结果:</p><p><img src="https://i.imgur.com/FYFVHzs.png" alt="虚拟程序输出结果" title="虚拟程序输出结果"></p><p>进程标识需要用十进制打印,而内存地址需要使用十六进制打印.</p><p>在C++中这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"十进制: "</span> &lt;&lt; dec &lt;&lt; <span class="number">255</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这将输出”十进制: 255”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"十六进制: 0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; <span class="number">255</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这将输出”十六进制: 0xFF”</p><p>..并且不要忘记<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自行尝试,不要直接查看解决方案.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_ARRAY_SIZE 128</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">varInt</span><span class="params">(<span class="number">123456</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">varString</span><span class="params">(<span class="string">"DefaultString"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> arrChar[CHAR_ARRAY_SIZE] = <span class="string">"Long char array right there -&gt;"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">ptr2int</span><span class="params">(&amp;varInt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">ptr2ptr</span><span class="params">(&amp;ptr2int)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>*** <span class="title">ptr2ptr2</span><span class="params">(&amp;ptr2ptr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Process ID: "</span> &lt;&lt; dec &lt;&lt; GetCurrentProcessId() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"varInt       (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;varInt &lt;&lt; <span class="string">") = "</span> &lt;&lt; dec &lt;&lt; varInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"varString    (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;varString &lt;&lt; <span class="string">") = "</span> &lt;&lt; varString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"arrChar["</span> &lt;&lt; dec &lt;&lt; CHAR_ARRAY_SIZE &lt;&lt; <span class="string">"] (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;arrChar &lt;&lt; <span class="string">") = "</span> &lt;&lt; arrChar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr2int      (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;ptr2int &lt;&lt; <span class="string">") = 0x"</span> &lt;&lt; ptr2int &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr2ptr      (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;ptr2ptr &lt;&lt; <span class="string">") = 0x"</span> &lt;&lt; ptr2ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr2ptr2     (0x"</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; (<span class="keyword">uintptr_t</span>)&amp;ptr2ptr2 &lt;&lt; <span class="string">") = 0x"</span> &lt;&lt; ptr2ptr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Press ENTER to print again."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"---------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习”读取-读取另一个进程的内存"><a href="#练习”读取-读取另一个进程的内存" class="headerlink" title="练习”读取:读取另一个进程的内存"></a>练习”读取:读取另一个进程的内存</h2><p>现在我们将从之前制作的虚拟程序的内存中读取变量的值并且覆盖它们,就像游戏作弊中一样.</p><p>在这个练习中,我们将使用函数<a href="https://msdn.microsoft.com/en-gb/library/windows/desktop/ms680553(v=vs.85" target="_blank" rel="noopener">ReadProcessMemory</a>.aspx从虚拟程序的内存中读取一些变量.</p><p>首先我们需要阅读<a href="https://msdn.microsoft.com/en-gb/library/windows/desktop/ms680553(v=vs.85" target="_blank" rel="noopener">MSDN上ReadProcessMemory的文档页面</a>.aspx)以了解此函数的工作原理以及我们该如何将他作为参数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>对于不熟悉Windows API的人来说第一个参数<em>_In_  HANDLE  hProcess</em>可能会非常棘手.</p><p>你的操作系统Windows的许多角色之一就是管理各种资源,访问和权限.</p><p>在我们的例子中你需要,访问我们的目标程序,并拥有足够的权限来读取和写入其内存.</p><p>这就是”HANDLE”类型的第一个参数,它本质上是操作系统给出的授权号.</p><p><strong>为了避免混淆,只需将句柄视为操作系统给与的授权号.</strong></p><p>为了得到我们需要的HANDLE,我们将使用Windows API函数<a href="https://msdn.microsoft.com/en-gb/library/windows/desktop/ms684320(v=vs.85" target="_blank" rel="noopener">OpenProcess</a>.aspx).</p><p>再次单击链接并仔细阅读文档,尝试了解它如何工作.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ BOOL  bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果你不明白什么是第一个参数,那么您肯定没有点击<a href="https://msdn.microsoft.com/en-gb/library/windows/desktop/ms684880(v=vs.85" target="_blank" rel="noopener">process access rights</a>.aspx)的链接，请始终按照这些链接了解提供该功能的内容.</p><p>你现在应该明白这是什么:这是我们要求的权限。</p><p>你可以在文档中看到许多权限,范围从PROCESS_ALL_ACCESS(对于流程对象的所有可能访问权限)到PROCESS_QUERY_LIMITED_INFORMATION(需要检索有关流程的某些信息),快速浏览所有这些权限,如果你不明白它们中的哪些允许你做，那没关系，你今天可以不完全明白.<br>为了简单起见,我们将使用PROCESS_ALL_ACCESS请求目标进程的所有可能权限.<br>一个好的做法是将请求的权限限制在最低限度,但我们会在稍后处理.</p><p>好的，第二个参数“_In_ BOOL bInheritHandle”.这个定义是句柄（请求的授权）对于子进程是可继承的。<br>我们并不真正在意这一点，简而言之，我们的程序将要求处理，如果我们将其设置为TRUE，我们程序中的所有子进程也将获得此授权.<br>由于我们不需要这个,我们将它设置为FALSE.</p><p>最终参数“_In_ DWORD dwProcessId”。<br>这是我们希望访问的进程的唯一进程标识号，通常缩写为进程标识或甚至是PID。<br>我们已经在虚拟程序中将它打印到控制台了。</p><p><img src="https://i.imgur.com/paoqiM8.png" alt=""></p><p>即使没有,我们可以使用任务管理器或者其他管理软件:</p><p><img src="https://i.imgur.com/xcwu9Jh.png" alt=""></p><p>如果你阅读了足够完整的OpenProcess文档,你会看到:</p><blockquote><p>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</p></blockquote><p>我们可以在我们的代码中添加一个简单的检查,以确保一切顺利.所以我们的代码应该看起来像这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, [OUR DUMMY PROGRAM PID]);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123; <span class="comment">// Failed to get a handle</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"OpenProcess failed. GetLastError = "</span> &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，如果你有错误，你也会得到GetLastError（）返回的错误代码，这将帮助你解决问题。<br>在这种情况下，<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681381(v=vs.85" target="_blank" rel="noopener">只需进入MSDN错误代码页并查找错误代码即可</a>.aspx)。</p>]]></content>
      
      
        <tags>
            
            <tag> GameHacking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一切的开始</title>
      <link href="/2018/04/08/%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2018/04/08/%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>尼采说：</p><blockquote><p>Man liebt zuletzt seine Begierde, und nicht das Begehrte.</p></blockquote><a id="more"></a><p><em>新起点,新气象.</em></p>]]></content>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
